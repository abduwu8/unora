import jsPDF from 'jspdf';

const MARGIN = 20;
const LINE_HEIGHT = 6.5;
const MAX_WIDTH = 170;
const PAGE_HEIGHT = 297;
const BOTTOM_MARGIN = 25;

function setPdfFont(doc, size = 10, style = 'normal') {
  doc.setFont('times', style);
  doc.setFontSize(size);
}

function checkPageBreak(doc, y, spaceNeeded = LINE_HEIGHT) {
  if (y + spaceNeeded > PAGE_HEIGHT - BOTTOM_MARGIN) {
    doc.addPage();
    return MARGIN;
  }
  return y;
}

function wrapText(doc, text, x, y) {
  const lines = doc.splitTextToSize(String(text || ''), MAX_WIDTH) || [];
  doc.text(lines, x, y);
  return y + lines.length * LINE_HEIGHT;
}

export function downloadDocumentsPdf(result, country) {
  const doc = new jsPDF({ unit: 'mm', format: 'a4' });
  setPdfFont(doc, 10, 'normal');
  let y = MARGIN;

  const title = `Required Documents for ${result.country || country}`;
  setPdfFont(doc, 16, 'bold');
  doc.setTextColor(0, 0, 0);
  doc.text(title, MARGIN, y);
  y += 12;

  if (result.summary) {
    setPdfFont(doc, 10, 'normal');
    y = wrapText(doc, result.summary, MARGIN, y) + 6;
    y = checkPageBreak(doc, y, 0);
  }

  if (result.documents && Array.isArray(result.documents) && result.documents.length > 0) {
    y = checkPageBreak(doc, y, 50);
    setPdfFont(doc, 11, 'bold');
    doc.text('Document Checklist', MARGIN, y);
    y += LINE_HEIGHT + 2;

    setPdfFont(doc, 10, 'normal');
    result.documents.forEach((docItem, idx) => {
      y = checkPageBreak(doc, y, 25);
      const name = typeof docItem === 'string' ? docItem : (docItem.name || docItem);
      const desc = docItem.description;
      const notes = docItem.notes;
      doc.text(`${idx + 1}. ${name}`, MARGIN, y);
      y += LINE_HEIGHT;
      if (desc) {
        y = wrapText(doc, `   ${desc}`, MARGIN, y);
        y = checkPageBreak(doc, y, 0);
      }
      if (notes) {
        setPdfFont(doc, 9, 'normal');
        doc.setTextColor(100, 100, 100);
        y = wrapText(doc, `   Note: ${notes}`, MARGIN, y);
        doc.setTextColor(0, 0, 0);
        setPdfFont(doc, 10, 'normal');
        y = checkPageBreak(doc, y, 0);
      }
      y += 3;
    });
    y += 4;
  }

  if (result.categories && Object.keys(result.categories).length > 0) {
    y = checkPageBreak(doc, y, 40);
    setPdfFont(doc, 11, 'bold');
    doc.text('By Category', MARGIN, y);
    y += LINE_HEIGHT + 2;

    setPdfFont(doc, 10, 'normal');
    Object.entries(result.categories).forEach(([category, docs]) => {
      y = checkPageBreak(doc, y, 30);
      doc.text(`${category}`, MARGIN, y);
      y += LINE_HEIGHT;
      const list = Array.isArray(docs) ? docs : [];
      list.forEach((d) => {
        y = checkPageBreak(doc, y, 15);
        const name = typeof d === 'string' ? d : (d.name || d);
        const desc = d.description;
        y = wrapText(doc, `• ${name}${desc ? ` — ${desc}` : ''}`, MARGIN + 4, y);
      });
      y += 4;
    });
  }

  if (result.importantNotes && (Array.isArray(result.importantNotes) ? result.importantNotes.length > 0 : result.importantNotes)) {
    y = checkPageBreak(doc, y, 30);
    y += 4;
    setPdfFont(doc, 10, 'bold');
    doc.text('Important Notes', MARGIN, y);
    y += LINE_HEIGHT;
    setPdfFont(doc, 9, 'normal');
    const notes = Array.isArray(result.importantNotes) ? result.importantNotes : [result.importantNotes];
    notes.forEach((note) => {
      y = checkPageBreak(doc, y, 15);
      y = wrapText(doc, `• ${note}`, MARGIN, y);
    });
    y += 4;
  }

  y = checkPageBreak(doc, y, 15);
  setPdfFont(doc, 8, 'normal');
  doc.setTextColor(120, 120, 120);
  doc.text('Confirm requirements on official government websites. Generated by Unora.', MARGIN, y);

  const filename = `documents-${(result.country || country || 'checklist').replace(/\s+/g, '-').slice(0, 25)}.pdf`;
  doc.save(filename);
}
